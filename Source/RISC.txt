 reduced instruction set computing  or risc  pronounced  risk    is a cpu design strategy based on the insight that a simplified instruction set  as opposed to a complex set  provides higher performance when combined with a microprocessor architecture capable of executing those instructions using fewer microprocessor cycles per instruction   a computer based on this strategy is a reduced instruction set computer  also called risc  the opposing architecture is called complex instruction set computing  i e  cisc     various suggestions have been made regarding a precise definition of risc  but the general concept is that of a system that uses a small  highly optimized set of instructions  rather than a more versatile set of instructions often found in other types of architectures  another common trait is that risc systems use the load store architecture   where memory is normally accessed only through specific instructions  rather than accessed as part of other instructions like add     although a number of systems from the     s and   s have been identified as being forerunners of risc  the modern version of the design dates to the     s  in particular  two projects at stanford university and university of california  berkeley are most associated with the popularization of this concept  stanford s design would go on to be commercialized as the successful mips architecture  while berkeley s risc gave its name to the entire concept  commercialized as the sparc  another success from this era were ibm s efforts that eventually led to the power architecture  as these projects matured  a wide variety of similar designs flourished in the late     s and especially the early     s  representing a major force in the unix workstation market as well as embedded processors in laser printers  routers and similar products     well known risc families include dec alpha  amd   k  arc  arm  atmel avr  blackfin  intel i    and i     mips  motorola        pa risc  power  including powerpc   risc v  superh  and sparc  in the   st century  the use of arm architecture processors in smart phones and tablet computers such as the ipad  android  and windows rt tablets provided a wide user base for risc based systems  risc processors are also used in supercomputers such as the k computer  the fastest on the top    list in       second at the      list  and fourth at the      list    and sequoia  the fastest in      and third in the      list             a number of systems  going back to the     s  and even     s  have been credited as the first risc architecture  partly based on their use of load store approach   the term risc was coined by david patterson of the berkeley risc project  although somewhat similar concepts had appeared before      the cdc      designed by seymour cray in      used a load store architecture with only two addressing modes  register register  and register immediate constant  and    opcodes  with the basic clock cycle instruction issue rate being    times faster than the memory access time   partly due to the optimized load store architecture of the cdc      jack dongarra states that it can be considered as a forerunner of modern risc systems  although a number of other technical barriers needed to be overcome for the development of a modern risc system      michael j  flynn views the first risc system as the ibm     design which began in      by john cocke  and completed in        the     was eventually produced in a single chip form as the romp in       which stood for  research opd office products division micro processor    as the name implies  this cpu was designed for  mini  tasks  and was also used in the ibm rt pc in       which turned out to be a commercial failure    but the     inspired several research projects  including new ones at ibm that would eventually lead to the ibm power instruction set architecture         the most public risc designs  however  were the results of university research programs run with funding from the darpa vlsi program  the vlsi program  practically unknown today  led to a huge number of advances in chip design  fabrication  and even computer graphics  the berkeley risc project started in      under the direction of david patterson and carlo h  sequin           berkeley risc was based on gaining performance through the use of pipelining and an aggressive use of a technique known as register windowing      in a traditional cpu  one has a small number of registers  and a program can use any register at any time  in a cpu with register windows  there are a huge number of registers  e g       but programs can only use a small number of them  e g  eight  at any one time  a program that limits itself to eight registers per procedure can make very fast procedure calls  the call simply moves the window  down  by eight  to the set of eight registers used by that procedure  and the return moves the window back    the berkeley risc project delivered the risc i processor in       consisting of only        transistors  compared with averages of about         in newer cisc designs of the era  risc i had only    instructions  and yet completely outperformed any other single chip design  they followed this up with the        transistor     instruction risc ii in       which ran over three times as fast as risc i       the mips architecture grew out of a graduate course by john l  hennessy at stanford university in       resulted in a functioning system in       and could run simple programs by         the mips approach emphasized an aggressive clock cycle and the use of the pipeline  making sure it could be run as  full  as possible    the mips system was followed by the mips x and in      hennessy and his colleagues formed mips computer systems      the commercial venture resulted in the r     microprocessor in       and was followed by the r     in            in the early     s  significant uncertainties surrounded the risc concept  and it was uncertain if it could have a commercial future  but by the mid     s the concepts had matured enough to be seen as commercially viable      in      hewlett packard started using an early implementation of their pa risc in some of their computers    in the meantime  the berkeley risc effort had become so well known that it eventually became the name for the entire concept and in      sun microsystems began shipping systems with the sparc processor  directly based on the berkeley risc ii system         the us government committee on innovations in computing and communications credits the acceptance of the viability of the risc concept to the success of the sparc system    the success of sparc renewed interest within ibm  which released new risc systems by      and by      risc processors were the foundation of a     billion server industry       since      a new open source  isa  risc v  is under development at the university of california  berkeley  for research purposes and as a free alternative to proprietary isa s   as of      version   of the userspace isa is fixed    the isa is designed to be extensible from a barebones core sufficient for a small embedded processor to supercomputer and cloud computing use with standard and chip designer defined extensions and coprocessors  it has been tested in silicon design with the rocket soc which is also available as an open source processor generator in the chisel language     a common misunderstanding of the phrase  reduced instruction set computer  is the mistaken idea that instructions are simply eliminated  resulting in a smaller set of instructions    in fact  over the years  risc instruction sets have grown in size  and today many of them have a larger set of instructions than many cisc cpus      some risc processors such as the powerpc have instruction sets as large as the cisc ibm system      for example  conversely  the dec pdp   clearly a cisc cpu because many of its instructions involve multiple memory accesses has only   basic instructions and a few extended instructions     the term  reduced  in that phrase was intended to describe the fact that the amount of work any single instruction accomplishes is reduced at most a single data memory cycle compared to the  complex instructions  of cisc cpus that may require dozens of data memory cycles in order to execute a single instruction    in particular  risc processors typically have separate instructions for i o and data processing citation needed    for any given level of general performance  a risc chip will typically have far fewer transistors dedicated to the core logic which originally allowed designers to increase the size of the register set and increase internal parallelism     other features that are typically found in risc architectures are     exceptions abound  of course  within both cisc and risc     risc designs are also more likely to feature a harvard memory model  where the instruction stream and the data stream are conceptually separated  this means that modifying the memory where code is held might not have any effect on the instructions executed by the processor  because the cpu has a separate instruction and data cache   at least until a special synchronization instruction is issued  on the upside  this allows both caches to be accessed simultaneously  which can often improve performance     many early risc designs also shared the characteristic of having a branch delay slot  a branch delay slot is an instruction space immediately following a jump or branch  the instruction in this space is executed  whether or not the branch is taken  in other words the effect of the branch is delayed   this instruction keeps the alu of the cpu busy for the extra time normally needed to perform a branch  nowadays the branch delay slot is considered an unfortunate side effect of a particular strategy for implementing some risc designs  and modern risc designs generally do away with it  such as powerpc and more recent versions of sparc and mips  citation needed    some aspects attributed to the first risc labeled designs around      include the observations that the memory restricted compilers of the time were often unable to take advantage of features intended to facilitate manual assembly coding  and that complex addressing modes take many cycles to perform due to the required additional memory accesses  it was argued that such functions would be better performed by sequences of simpler instructions if this could yield implementations small enough to leave room for many registers  reducing the number of slow memory accesses  in these simple designs  most instructions are of uniform length and similar structure  arithmetic operations are restricted to cpu registers and only separate load and store instructions access memory  these properties enable a better balancing of pipeline stages than before  making risc pipelines significantly more efficient and allowing higher clock frequencies     in the early days of the computer industry  programming was done in assembly language or machine code  which encouraged powerful and easy to use instructions  cpu designers therefore tried to make instructions that would do as much work as feasible  with the advent of higher level languages  computer architects also started to create dedicated instructions to directly implement certain central mechanisms of such languages  another general goal was to provide every possible addressing mode for every instruction  known as orthogonality  to ease compiler implementation  arithmetic operations could therefore often have results as well as operands directly in memory  in addition to register or immediate      the attitude at the time was that hardware design was more mature than compiler design so this was in itself also a reason to implement parts of the functionality in hardware or microcode rather than in a memory constrained compiler  or its generated code  alone  after the advent of risc  this philosophy became retroactively known as complex instruction set computing  or cisc     cpus also had relatively few registers  for several reasons     an important force encouraging complexity was very limited main memories  on the order of kilobytes   it was therefore advantageous for the code density the density of information held in computer programs to be high  leading to features such as highly encoded  variable length instructions  doing data loading as well as calculation  as mentioned above   these issues were of higher priority than the ease of decoding such instructions     an equally important reason was that main memories were quite slow  a common type was ferrite core memory   by using dense information packing  one could reduce the frequency with which the cpu had to access this slow resource  modern computers face similar limiting factors  main memories are slow compared to the cpu and the fast cache memories employed to overcome this are limited in size  this may partly explain why highly encoded instruction sets have proven to be as useful as risc designs in modern computers     risc was developed as an alternative to what is now known as cisc  over the years  other strategies have been implemented as alternatives to risc and cisc  some examples are vliw  misc  oisc  massive parallel processing  systolic array  reconfigurable computing  and dataflow architecture     in the mid     s  researchers  particularly john cocke  at ibm  and similar projects elsewhere  demonstrated that the majority of combinations of these orthogonal addressing modes and instructions were not used by most programs generated by compilers available at the time  it proved difficult in many cases to write a compiler with more than limited ability to take advantage of the features provided by conventional cpus     it was also discovered that  on microcoded implementations of certain architectures  complex operations tended to be slower than a sequence of simpler operations doing the same thing  this was in part an effect of the fact that many designs were rushed  with little time to optimize or tune every instruction  but only those used most often  one infamous example was the vax s index instruction       as mentioned elsewhere  core memory had long since been slower than many cpu designs  the advent of semiconductor memory reduced this difference  but it was still apparent that more registers  and later caches  would allow higher cpu operating frequencies  additional registers would require sizeable chip or board areas which  at the time         could be made available if the complexity of the cpu logic was reduced     yet another impetus of both risc and other designs came from practical measurements on real world programs  andrew tanenbaum summed up many of these  demonstrating that processors often had oversized immediates  for instance  he showed that     of all the constants in a program would fit in    bits  yet many cpu designs dedicated    or    bits to store them  this suggests that  to reduce the number of memory accesses  a fixed length machine could store constants in unused bits of the instruction word itself  so that they would be immediately ready when the cpu needs them  much like immediate addressing in a conventional design   this required small opcodes in order to leave room for a reasonably sized constant in a    bit instruction word     since many real world programs spend most of their time executing simple operations  some researchers decided to focus on making those operations as fast as possible  the clock rate of a cpu is limited by the time it takes to execute the slowest sub operation of any instruction  decreasing that cycle time often accelerates the execution of other instructions    the focus on  reduced instructions  led to the resulting machine being called a  reduced instruction set computer   risc   the goal was to make instructions so simple that they could easily be pipelined  in order to achieve a single clock throughput at high frequencies     later  it was noted that one of the most significant characteristics of risc processors was that external memory was only accessible by a load or store instruction  all other instructions were limited to internal registers  this simplified many aspects of processor design  allowing instructions to be fixed length  simplifying pipelines  and isolating the logic for dealing with the delay in completing a memory access  cache miss  etc   to only two instructions  this led to risc designs being referred to as load store architectures       one more issue is that some complex instructions are difficult to restart  e g  following a page fault  in some cases  restarting from the beginning will work  although wasteful   but in many cases this would give incorrect results  therefore the machine needs to have some hidden state to remember which parts went through and what remains to be done  with a load store machine  the program counter is sufficient to describe the state of the machine     the main distinguishing feature of risc is that the instruction set is optimized for a highly regular instruction pipeline flow    all the other features associated with risc branch delay slots  separate instruction and data caches  load store architecture  large register set  etc  may seem to be a random assortment of unrelated features  but each of them is helpful in maintaining a regular pipeline flow that completes an instruction every clock cycle     some cpus have been specifically designed to have a very small set of instructions   but these designs are very different from classic risc designs  so they have been given other names such as minimal instruction set computer  misc   or transport triggered architecture  tta   etc     despite many successes  risc has made few inroads into the desktop pc and commodity server markets  where intel s x   platform remains the dominant processor architecture  there are three main reasons for this     outside of the desktop arena  however  the arm architecture  risc and born at about the same time as sparc  has to a degree broken the intel stranglehold with its widespread use in smartphones  tablets and many forms of embedded device  it is also the case that since the pentium pro  p   intel has been using an internal risc processor core for its processors       while early risc designs differed significantly from contemporary cisc designs  by      the highest performing cpus in the risc line were almost indistinguishable from the highest performing cpus in the cisc line           risc architectures are now used across a wide range of platforms  from cellular telephones and tablet computers to some of the world s fastest supercomputers such as the k computer  the fastest on the top    list in            by the beginning of the   st century  the majority of low end and mobile systems relied on risc architectures    examples include      