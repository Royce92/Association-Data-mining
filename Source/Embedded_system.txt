 an embedded system is a computer system with a dedicated function within a larger mechanical or electrical system  often with real time computing constraints    it is embedded as part of a complete device often including hardware and mechanical parts  embedded systems control many devices in common use today      properties typical of embedded computers when compared with general purpose ones are e g  low power consumption  small size  rugged operating ranges and low per unit cost  this comes at the price of limited processing resources  which make them significantly more difficult to program and to interface with  however  by building intelligence mechanisms on the top of the hardware  taking advantage of possible existing sensors and the existence of a network of embedded units  one can both optimally manage available resources at the unit and network levels as well as provide augmented functionalities  well beyond those available   for example  intelligent techniques can be designed to manage power consumption of embedded systems      modern embedded systems are often based on microcontrollers  i e  cpus with integrated memory or peripheral interfaces   but ordinary microprocessors  using external chips for memory and peripheral interface circuits  are also still common  especially in more complex systems  in either case  the processor s  used may be types ranging from general purpose to those specialised in certain class of computations  or even custom designed for the application at hand  a common standard class of dedicated processors is the digital signal processor  dsp      since the embedded system is dedicated to specific tasks  design engineers can optimize it to reduce the size and cost of the product and increase the reliability and performance  some embedded systems are mass produced  benefiting from economies of scale     embedded systems range from portable devices such as digital watches and mp  players  to large stationary installations like traffic lights  factory controllers  and largely complex systems like hybrid vehicles  mri  and avionics  complexity varies from low  with a single microcontroller chip  to very high with multiple units  peripherals and networks mounted inside a large chassis or enclosure             embedded systems are commonly found in consumer  cooking  industrial  automotive  medical  commercial and military applications     telecommunications systems employ numerous embedded systems from telephone switches for the network to cell phones at the end user  computer networking uses dedicated routers and network bridges to route data     consumer electronics include personal digital assistants  pdas   mp  players  mobile phones  videogame consoles  digital cameras  dvd players  gps receivers  and printers  household appliances  such as microwave ovens  washing machines and dishwashers  include embedded systems to provide flexibility  efficiency and features  advanced hvac systems use networked thermostats to more accurately and efficiently control temperature that can change by time of day and season  home automation uses wired  and wireless networking that can be used to control lights  climate  security  audio visual  surveillance  etc   all of which use embedded devices for sensing and controlling     transportation systems from flight to automobiles increasingly use embedded systems  new airplanes contain advanced avionics such as inertial guidance systems and gps receivers that also have considerable safety requirements  various electric motors   brushless dc motors  induction motors and dc motors   use electric electronic motor controllers  automobiles  electric vehicles  and hybrid vehicles increasingly use embedded systems to maximize efficiency and reduce pollution  other automotive safety systems include anti lock braking system  abs   electronic stability control  esc esp   traction control  tcs  and automatic four wheel drive     medical equipment uses embedded systems for vital signs monitoring  electronic stethoscopes for amplifying sounds  and various medical imaging  pet  spect  ct  mri  for non invasive internal inspections  embedded systems within medical equipment are often powered by industrial computers      embedded systems are used in transportation  fire safety  safety and security  medical applications and life critical systems  as these systems can be isolated from hacking and thus  be more reliable citation needed for fire safety  the systems can be designed to have greater ability to handle higher temperatures and continue to operate  in dealing with security  the embedded systems can be self sufficient and be able to deal with cut electrical and communication systems     a new class of miniature wireless devices called motes are networked wireless sensors  wireless sensor networking  wsn  makes use of miniaturization made possible by advanced ic design to couple full wireless subsystems to sophisticated sensors  enabling people and companies to measure a myriad of things in the physical world and act on this information through it monitoring and control systems  these motes are completely self contained  and will typically run off a battery source for years before the batteries need to be changed or charged     embedded wi fi modules provide a simple means of wirelessly enabling any device which communicates via a serial port     one of the very first recognizably modern embedded systems was the apollo guidance computer  developed by charles stark draper at the mit instrumentation laboratory  at the project s inception  the apollo guidance computer was considered the riskiest item in the apollo project as it employed the then newly developed monolithic integrated circuits to reduce the size and weight  an early mass produced embedded system was the autonetics d    guidance computer for the minuteman missile  released in       when the minuteman ii went into production in       the d    was replaced with a new computer that was the first high volume use of integrated circuits  this program alone reduced prices on quad nand gate ics from       each to    eachcitation needed  permitting their use in commercial products     since these early applications in the     s  embedded systems have come down in price and there has been a dramatic rise in processing power and functionality  an early microprocessor for example  the intel       was designed for calculators and other small systems but still required external memory and support chips  in      national engineering manufacturers association released a  standard  for programmable microcontrollers  including almost any computer based controllers  such as single board computers  numerical  and event based controllers     as the cost of microprocessors and microcontrollers fell it became feasible to replace expensive knob based analog components such as potentiometers and variable capacitors with up down buttons or knobs read out by a microprocessor even in consumer products  by the early     s  memory  input and output system components had been integrated into the same chip as the processor forming a microcontroller  microcontrollers find applications where a general purpose computer would be too costly     a comparatively low cost microcontroller may be programmed to fulfill the same role as a large number of separate components  although in this context an embedded system is usually more complex than a traditional solution  most of the complexity is contained within the microcontroller itself  very few additional components may be needed and most of the design effort is in the software  software prototype and test can be quicker compared with the design and construction of a new circuit not using an embedded processor     embedded systems are designed to do some specific task  rather than be a general purpose computer for multiple tasks  some also have real time performance constraints that must be met  for reasons such as safety and usability  others may have low or no performance requirements  allowing the system hardware to be simplified to reduce costs     embedded systems are not always standalone devices  many embedded systems consist of small  computerized parts within a larger device that serves a more general purpose  for example  the gibson robot guitar features an embedded system for tuning the strings  but the overall purpose of the robot guitar is  of course  to play music   similarly  an embedded system in an automobile provides a specific function as a subsystem of the car itself     the program instructions written for embedded systems are referred to as firmware  and are stored in read only memory or flash memory chips  they run with limited computer hardware resources  little memory  small or non existent keyboard or screen     embedded systems range from no user interface at all  in systems dedicated only to one task  to complex graphical user interfaces that resemble modern computer desktop operating systems  simple embedded devices use buttons  leds  graphic or character lcds  hd      lcd for example  with a simple menu system     more sophisticated devices which use a graphical screen with touch sensing or screen edge buttons provide flexibility while minimizing space used  the meaning of the buttons can change with the screen  and selection involves the natural behavior of pointing at what s desired  handheld systems often have a screen with a  joystick button  for a pointing device     some systems provide user interface remotely with the help of a serial  e g  rs      usb  i c  etc   or network  e g  ethernet  connection  this approach gives several advantages  extends the capabilities of embedded system  avoids the cost of a display  simplifies bsp and allows one to build a rich user interface on the pc  a good example of this is the combination of an embedded web server running on an embedded device  such as an ip camera  or a network router  the user interface is displayed in a web browser on a pc connected to the device  therefore needing no software to be installed     embedded processors can be broken into two broad categories  ordinary microprocessors   p  use separate integrated circuits for memory and peripherals  microcontrollers   c  have on chip peripherals  thus reducing power consumption  size and cost  in contrast to the personal computer market  many different basic cpu architectures are used  since software is custom developed for an application and is not a commodity product installed by the end user  both von neumann as well as various degrees of harvard architectures are used  risc as well as non risc processors are found  word lengths vary from   bit to    bits and beyond  although the most typical remain      bit  most architectures come in a large number of different variants and shapes  many of which are also manufactured by several different companies     numerous microcontrollers have been developed for embedded systems use  general purpose microprocessors are also used in embedded systems  but generally require more support circuitry than microcontrollers     pc     and pc      are examples of standards for ready made computer boards intended for small  low volume embedded and ruggedized systems  mostly x   based  these are often physically small compared to a standard pc  although still quite large compared to most simple       bit  embedded systems  they often use dos  linux  netbsd  or an embedded real time operating system such as microc os ii  qnx or vxworks  sometimes these boards use non x   processors     in certain applications  where small size or power efficiency are not primary concerns  the components used may be compatible with those used in general purpose x   personal computers  boards such as the via epia range help to bridge the gap by being pc compatible but highly integrated  physically smaller or have other attributes making them attractive to embedded engineers  the advantage of this approach is that low cost commodity components may be used along with the same software development tools used for general software development  systems built in this way are still regarded as embedded since they are integrated into larger devices and fulfill a single role  examples of devices that may adopt this approach are atms and arcade machines  which contain code specific to the application     however  most ready made embedded systems boards are not pc centered and do not use the isa or pci busses  when a system on a chip processor is involved  there may be little benefit to having a standarized bus connecting discrete components  and the environment for both hardware and software tools may be very different     one common design style uses a small system module  perhaps the size of a business card  holding high density bga chips such as an arm based system on a chip processor and peripherals  external flash memory for storage  and dram for runtime memory  the module vendor will usually provide boot software and make sure there is a selection of operating systems  usually including linux and some real time choices  these modules can be manufactured in high volume  by organizations familiar with their specialized testing issues  and combined with much lower volume custom mainboards with application specific external peripherals     a common array of n configuration for very high volume embedded systems is the system on a chip  soc  which contains a complete system consisting of multiple processors  multipliers  caches and interfaces on a single chip  socs can be implemented as an application specific integrated circuit  asic  or using a field programmable gate array  fpga      embedded systems talk with the outside world via peripherals  such as     as with other software  embedded system designers use compilers  assemblers  and debuggers to develop embedded system software  however  they may also use some more specific tools     software tools can come from several sources     as the complexity of embedded systems grows  higher level tools and operating systems are migrating into machinery where it makes sense  for example  cellphones  personal digital assistants and other consumer computers often need significant software that is purchased or provided by a person other than the manufacturer of the electronics  in these systems  an open programming environment such as linux  netbsd  osgi or embedded java is required so that the third party software provider can sell to a large market     embedded debugging may be performed at different levels  depending on the facilities available  from simplest to most sophisticated they can be roughly grouped into the following areas     unless restricted to external debugging  the programmer can typically load and run software through the tools  view the code running in the processor  and start or stop its operation  the view of the code may be as hll source code  assembly code or mixture of both     because an embedded system is often composed of a wide variety of elements  the debugging strategy may vary  for instance  debugging a software   and microprocessor   centric embedded system is different from debugging an embedded system where most of the processing is performed by peripherals  dsp  fpga  co processor   an increasing number of embedded systems today use more than one single processor core  a common problem with multi core development is the proper synchronization of software execution  in such a case  the embedded system design may wish to check the data traffic on the busses between the processor cores  which requires very low level debugging  at signal bus level  with a logic analyzer  for instance     real time operating systems  rtos  often supports tracing of operating system events  a graphical view is presented by a host pc tool  based on a recording of the system behavior  the trace recording can be performed in software  by the rtos  or by special tracing hardware  rtos tracing allows developers to understand timing and performance issues of the software system and gives a good understanding of the high level system behavior  commercial tools like rtxc quadros or iar systems exist     embedded systems often reside in machines that are expected to run continuously for years without errors  and in some cases recover by themselves if an error occurs  therefore the software is usually developed and tested more carefully than that for personal computers  and unreliable mechanical moving parts such as disk drives  switches or buttons are avoided     specific reliability issues may include     a variety of techniques are used  sometimes in combination  to recover from errors both software bugs such as memory leaks  and also soft errors in the hardware     for high volume systems such as portable music players or mobile phones  minimizing cost is usually the primary design consideration  engineers typically select hardware that is just  good enough  to implement the necessary functions     for low volume or prototype embedded systems  general purpose computers may be adapted by limiting the programs or by replacing the operating system with a real time operating system     there are several different types of software architecture in common use     in this design  the software simply has a loop  the loop calls subroutines  each of which manages a part of the hardware or software     some embedded systems are predominantly controlled by interrupts  this means that tasks performed by the system are triggered by different kinds of events  an interrupt could be generated  for example  by a timer in a predefined frequency  or by a serial port controller receiving a byte     these kinds of systems are used if event handlers need low latency  and the event handlers are short and simple  usually  these kinds of systems run a simple task in a main loop also  but this task is not very sensitive to unexpected delays     sometimes the interrupt handler will add longer tasks to a queue structure  later  after the interrupt handler has finished  these tasks are executed by the main loop  this method brings the system close to a multitasking kernel with discrete processes     a nonpreemptive multitasking system is very similar to the simple control loop scheme  except that the loop is hidden in an api  the programmer defines a series of tasks  and each task gets its own environment to  run  in  when a task is idle  it calls an idle routine  usually called  pause    wait    yield    nop   stands for no operation   etc     the advantages and disadvantages are similar to that of the control loop  except that adding new software is easier  by simply writing a new task  or adding to the queue     in this type of system  a low level piece of code switches between tasks or threads based on a timer  connected to an interrupt   this is the level at which the system is generally considered to have an  operating system  kernel  depending on how much functionality is required  it introduces more or less of the complexities of managing multiple tasks running conceptually in parallel     as any code can potentially damage the data of another task  except in larger systems using an mmu  programs must be carefully designed and tested  and access to shared data must be controlled by some synchronization strategy  such as message queues  semaphores or a non blocking synchronization scheme     because of these complexities  it is common for organizations to use a real time operating system  rtos   allowing the application programmers to concentrate on device functionality rather than operating system services  at least for large systems  smaller systems often cannot afford the overhead associated with a generic real time system  due to limitations regarding memory size  performance  or battery life  the choice that an rtos is required brings in its own issues  however  as the selection must be done prior to starting to the application development process  this timing forces developers to choose the embedded operating system for their device based upon current requirements and so restricts future options to a large extent    the restriction of future options becomes more of an issue as product life decreases  additionally the level of complexity is continuously growing as devices are required to manage variables such as serial  usb  tcp ip  bluetooth  wireless lan  trunk radio  multiple channels  data and voice  enhanced graphics  multiple states  multiple threads  numerous wait states and so on  these trends are leading to the uptake of embedded middleware in addition to a real time operating system     a microkernel is a logical step up from a real time os  the usual arrangement is that the operating system kernel allocates memory and switches the cpu to different threads of execution  user mode processes implement major functions such as file systems  network interfaces  etc     in general  microkernels succeed when the task switching and intertask communication is fast and fail when they are slow     exokernels communicate efficiently by normal subroutine calls  the hardware and all the software in the system are available to and extensible by application programmers     in this case  a relatively large kernel with sophisticated capabilities is adapted to suit an embedded environment  this gives programmers an environment similar to a desktop operating system like linux or microsoft windows  and is therefore very productive for development  on the downside  it requires considerably more hardware resources  is often more expensive  and  because of the complexity of these kernels  can be less predictable and reliable     common examples of embedded monolithic kernels are embedded linux and windows ce     despite the increased cost in hardware  this type of embedded system is increasing in popularity  especially on the more powerful embedded devices such as wireless routers and gps navigation systems  here are some of the reasons     a small fraction of embedded systems require safe  timely  reliable  or efficient behavior unobtainable with any of the above architectures  in this case an organization builds a system to suit  in some cases  the system may be partitioned into a  mechanism controller  using special techniques  and a  display controller  with a conventional operating system  a communication system passes data between the two     in addition to the core operating system  many embedded systems have additional upper layer software components  these components consist of networking protocol stacks like can  tcp ip  ftp  http  and https  and also included storage capabilities like fat and flash memory management systems  if the embedded device has audio and video capabilities  then the appropriate drivers and codecs will be present in the system  in the case of the monolithic kernels  many of these software layers are included  in the rtos category  the availability of the additional software components depends upon the commercial offering  