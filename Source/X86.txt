 x   is a family of backward compatible instruction set architecturesa based on the intel      cpu and its intel      variant  the      was introduced in      as a fully    bit extension of intel s   bit based      microprocessor  with memory segmentation as a solution for addressing more memory than can be covered by a plain    bit address  the term  x    came into being because the names of several successors to the intel s      processor ended in       including                     and       processors     many additions and extensions have been added to the x   instruction set over the years  almost consistently with full backward compatibility b the architecture has been implemented in processors from intel  cyrix  amd  via and many other companies  there are also open implementations  such as the zet soc platform      the term is not synonymous with ibm pc compatibility as this implies a multitude of other computer hardware  embedded systems as well as general purpose computers used x   chips before the pc compatible market started c some of them before the ibm pc itself             in the     s and early     s when the      and       were still in common use  the term x   usually represented any      compatible cpu  today  however  x   usually implies a binary compatibility also with the    bit instruction set of the        this is due to the fact that this instruction set has become something of a lowest common denominator for many modern operating systems and probably also because the term became common after the introduction of the       in          a few years after the introduction of the      and       intel added some complexity to its naming scheme and terminology as the  iapx  of the ambitious but ill fated intel iapx     processor was tried on the more successful      family of chips d applied as a kind of system level prefix  an      system  including coprocessors such as      and or       as well as simpler intel specific system chips e was thereby described as an iapx    system  f there were also terms irmx  for operating systems   isbc  for single board computers   and isbx  for multimodule boards based on the      architecture xa    all together under the heading microsystem       however  this naming scheme was quite temporary  lasting for a few years during the early     s      although the      was primarily developed for embedded systems and small multi user or single user computers  largely as a response to the successful      compatible zilog z     the x   line soon grew in features and processing power  today  x   is ubiquitous in both stationary and portable personal computers  and is also used in midrange computers  workstations  servers and most new supercomputer clusters of top    list  a large amount of software  including operating systems  oss  such as dos  windows  linux  bsd  solaris and mac os x  functions with x   based hardware     modern x   is relatively uncommon in embedded systems  however  and small low power applications  using tiny batteries  as well as low cost microprocessor markets  such as home appliances and toys  lack any significant x   presence g simple   bit and    bit based architectures are common here  although the x   compatible via c   via nano  amd s geode  athlon neo and intel atom are examples of     and    bit designs used in some relatively low power and low cost segments     there have been several attempts  including by intel itself  to end the market dominance of the  inelegant  x   architecture designed directly from the first simple   bit microprocessors  examples of this are the iapx      a project originally named the  intel          the intel      intel     and the intel hewlett packard itanium architecture  however  the continuous refinement of x   microarchitectures  circuitry and semiconductor manufacturing would make it hard to replace x   in many segments  amd s    bit extension of x    which intel eventually responded to with a compatible design   and the scalability of x   chips such as the eight core intel xeon and    core amd opteron is underlining x   as an example of how continuous refinement of established industry standards can resist the competition from completely new architectures       the table below lists brands of common   consumer targeted processors implementing the x   instruction set  grouped by generations that emphasize important events of x   history  note  cpu generations are not strict   each generation is characterized by significantly improved or commercially successful processor microarchitecture designs     the x   architecture was first used for the intel      central processing unit  cpu  released during       a fully    bit design based on the earlier   bit based      and       although not binary compatible  it was designed to allow assembly language programs written for these processors  as well as the contemporary       to be mechanically translated into equivalent      assembly  this made the new processor a tempting software migration route for many customers     however  the    bit external data bus of the      implied fairly significant hardware redesign  as well as other complications and expenses  to address this obstacle  intel introduced the almost identical       basically an      with an   bit external databus that permitted simpler printed circuit boards and demanded fewer    bit wide  dram chips  it was also more easily interfaced to already established  i e  low cost    bit system and peripheral chips  among other  non technical factors  this contributed to ibm s decision to design a personal computer based on the       despite the presence of    bit microprocessors from motorola  zilog  national semiconductor and others  as well as several established   bit processors that were also considered  largely as a result of ibm s position and historical reputation as a strong and dominant computer company  the resulting ibm pc subsequently became preferred to z   based cp m systems  apple iis  and other popular computers as the de facto standard for personal computers  thus enabling the      and its successors to dominate this large part of the microprocessor market     another factor was that the advanced but non compatible    bit intel       alias iapx      failed in the market around the time the original ibm pc was initiated  the new and fast       actually contributed to the disappointment in the performance of the semi contemporary      during early        the        initiated simultaneously with the        was intended for embedded systems  and would therefore have had a large market anyway   the market failure of the    bit      was a significant impetus for intel to continue to develop more advanced      compatible processors instead  such as the        a    bit extension of the well performing            at various times  companies such as ibm  nec h amd  ti  stm  fujitsu  oki  siemens  cyrix  intersil  c t  nexgen  umc  and dm p started to design or manufacturei x   processors  cpus  intended for personal computers as well as embedded systems  such x   implementations are seldom simple copies but often employ different internal microarchitectures as well as different solutions at the electronic and physical levels  quite naturally  early compatible microprocessors were    bit  while    bit designs were developed much later  for the personal computer market  real quantities started to appear around      with i    and i    compatible processors  often named similarly to intel s original chips  other companies  which designed or manufactured x   or x   processors  include itt corporation  national semiconductor  ulsi system technology  and weitek     following the fully pipelined i     intel introduced the pentium brand name  which  unlike numbers  could be trademarked  for their new set of superscalar x   designs  with the x   naming scheme now legally cleared  other x   vendors had to choose different names for their x   compatible products  and initially some chose to continue with variations of the numbering scheme  ibm partnered with cyrix to produce the  x   and then the very efficient  x    m   and  x  mx  mii  lines of cyrix designs  which were the first x   microprocessors implementing register renaming to enable speculative execution  amd meanwhile designed and manufactured the advanced but delayed  k    k    which  internally  was closely based on amd s earlier   k risc design  similar to nexgen s nx     it used a strategy such that dedicated pipeline stages decode x   instructions into uniform and easily handled micro operations  a method that has remained the basis for most x   designs to this day     some early versions of these microprocessors had heat dissipation problems  the  x   was also affected by a few minor compatibility problems  the nx    lacked a floating point unit  fpu  and  the then crucial  pin compatibility  while the k  had somewhat disappointing performance when it was  eventually  introduced  customer ignorance of alternatives to the pentium series further contributed to these designs being comparatively unsuccessful  despite the fact that the k  had very good pentium compatibility and the  x   was significantly faster than the pentium on integer code j amd later managed to establish itself as a serious contender with the k  set of processors  which gave way to the very successful athlon and opteron  there were also other contenders  such as centaur technology  formerly idt   rise technology  and transmeta  via technologies  energy efficient c  and c  processors  which were designed by the centaur company  have been sold for many years  centaur s newest design  the via nano  is their first processor with superscalar and speculative execution  it was  perhaps interestingly  introduced at about the same time as intel s first  in order  processor since the p  pentium  the intel atom     the instruction set architecture has twice been extended to a larger word size  in       intel released the    bit        later known as i     which gradually replaced the earlier    bit chips in computers  although typically not in embedded systems  during the following years  this extended programming model was originally referred to as the i    architecture  like its first implementation  but intel later dubbed it ia    when introducing its  unrelated  ia    architecture     in            amd extended this    bit architecture to   xa bits and referred to it as x      in early documents and later as amd    intel soon adopted amd s architectural extensions under the name ia   e  later using the name em  t and finally using intel     microsoft and sun microsystems also use term  x     while many linux distributions also use the  amd    term  microsoft windows  for example  designates its    bit versions as  x    and    bit versions as  x     while installation files of    bit windows versions are required to be placed into a directory called  amd          the x   architecture is a variable instruction length  primarily  cisc  design with emphasis on backward compatibility  the instruction set is not typical cisc  however  but basically an extended version of the simple eight bit      and      architectures  byte addressing is enabled and words are stored in memory with little endian byte order  memory access to unaligned addresses is allowed for all valid word sizes  the largest native size for integer arithmetic and memory addresses  or offsets  is        or   xa bits depending on architecture generation  newer processors include direct support for smaller integers as well   multiple scalar values can be handled simultaneously via the simd unit present in later generations  as described below k immediate addressing offsets and immediate data may be expressed as   bit quantities for the frequently occurring cases or contexts where a           range is enough  typical instructions are therefore   or   bytes in length  although some are much longer  and some are single byte      to further conserve encoding space  most registers are expressed in opcodes using three or four bits  the latter via an opcode prefix in    bit mode  while at most one operand to an instruction can be a memory location l however  this memory operand may also be the destination  or a combined source and destination   while the other operand  the source  can be either register or immediate  among other factors  this contributes to a code size that rivals eight bit machines and enables efficient use of instruction cache memory  the relatively small number of general registers  also inherited from its   bit ancestors  has made register relative addressing  using small immediate offsets  an important method of accessing operands  especially on the stack  much work has therefore been invested in making such accesses as fast as register accesses  i e  a one cycle instruction throughput  in most circumstances where the accessed data is available in the top level cache     a dedicated floating point processor with    bit internal registers  the       was developed for the original       this microprocessor subsequently developed into the extended        and later processors incorporated a backward compatible version of this functionality on the same microprocessor as the main processor  in addition to this  modern x   designs also contain a simd unit  see sse below  where instructions can work in parallel on  one or two      bit words  each containing   or   floating point numbers  each    or   xa bits wide respectively   or alternatively          or    integers  each            or  xa bits wide respectively      the presence of wide simd registers means that existing x   processors can load or store up to    xa bits of memory data in a single instruction and also perform bitwise operations  although not integer arithmeticm  on full     bits quantities in parallel  intel s sandy bridge processors added the avx  advanced vector extensions  instructions  widening the simd registers to     bits  knights corner  the architecture used by intel on their xeon phi co processors  uses     bit wide simd registers     during execution  current x   processors employ a few extra decoding steps to split most instructions into smaller pieces called micro operations  these are then handed to a control unit that buffers and schedules them in compliance with x   semantics so that they can be executed  partly in parallel  by one of several  more or less specialized  execution units  these modern x   designs are thus superscalar  and also capable of out of order and speculative execution  via register renaming   which means they may execute multiple  partial or complete  x   instructions simultaneously  and not necessarily in the same order as given in the instruction stream       when introduced  in the mid     s  this method was sometimes referred to as a  risc core  or as  risc translation   partly for marketing reasons  but also because these micro operations share some properties with certain types of risc instructions  however  traditional microcode  used since the     s  also inherently shares many of the same properties  the new method differs mainly in that the translation to micro operations now occurs asynchronously  not having to synchronize the execution units with the decode steps opens up possibilities for more analysis of the  buffered  code stream  and therefore permits detection of operations that can be performed in parallel  simultaneously feeding more than one execution unit     the latest processors also do the opposite when appropriate  they combine certain x   sequences  such as a compare followed by a conditional jump  into a more complex micro op which fits the execution model better and thus can be executed faster or with less machine resources involved     another way to try to improve performance is to cache the decoded micro operations  so the processor can directly access the decoded micro operations from a special cache  instead of decoding them again  intel followed this approach with the execution trace cache feature in their netburst microarchitecture  for pentium   processors  and later in the decoded stream buffer  for core branded processors since sandy bridge        transmeta used a completely different method in their x   compatible cpus  they used just in time translation to convert x   instructions to the cpu s native vliw instruction set  transmeta argued that their approach allows for more power efficient designs since the cpu can forgo the complicated decode step of more traditional x   implementations     minicomputers during the late     s were running up against the    bit    kb address limit  as memory had become cheaper  some minicomputers like the pdp    used complex bank switching schemes  or  in the case of digital s vax  redesigned much more expensive processors which could directly handle    bit addressing and data  the original       developed from the simple      microprocessor and primarily aiming at very small and inexpensive computers and other specialized devices  instead adopted simple segment registers which increased the memory address width by only  xa bits  by multiplying a    kb address by     the    bit address could address a total of one megabyte            bytes  which was quite a large amount for a small computer at the time  the concept of segment registers was not new to many mainframes which used segment registers to swap quickly to different tasks  in practice  on the x   it was  is  a much criticized implementation which greatly complicated many common programming tasks and compilers  however  the architecture soon allowed linear    bit addressing  starting with the       in late       but major actors  such as microsoft  took several years to convert their    bit based systems  the        and        was therefore largely used as a fast  but still    bit based       for many years     data and code could be managed within  near     bit segments within   xa kb portions of the total  xa mb address space  or a compiler could operate in a  far  mode using    bit segment offset pairs reaching  only   xa mb  while that would also prove to be quite limiting by the mid     s  it was working for the emerging pc market  and made it very simple to translate software from the older                   and z   to the newer processor  during       the    bit segment addressing model was effectively factored out by the introduction of    bit offset registers  in the     design     in real mode  segmentation is achieved by shifting the segment address left by  xa bits and adding an offset in order to receive a final    bit address  for example  if ds is a   h and si is     h  ds si will point at the absolute address ds     h   si   a    h  thus the total address space in real mode is     bytes  or   mb  quite an impressive figure for       all memory addresses consist of both a segment and offset  every type of access  code  data  or stack  has a default segment register associated with it  for data the register is usually ds  for code it is cs  and for stack it is ss   for data accesses  the segment register can be explicitly specified  using a segment override prefix  to use any of the four segment registers     in this scheme  two different segment offset pairs can point at a single absolute location  thus  if ds is a   h and si is     h  ds si will point at the same a    h as above  this scheme makes it impossible to use more than four segments at once  cs and ss are vital for the correct functioning of the program  so that only ds and es can be used to point to data segments outside the program  or  more precisely  outside the currently executing segment of the program  or the stack     in protected mode  a segment register no longer contains the physical address of the beginning of a segment  but contain a  selector  that points to a system level structure called a segment descriptor  a segment descriptor contains the physical address of the beginning of the segment  the length of the segment  and access permissions to that segment  the offset is checked against the length of the segment  with offsets referring to locations outside the segment causing an exception  offsets referring to locations inside the segment are combined with the physical address of the beginning of the segment to get the physical address corresponding to that offset     the segmented nature can make programming and compiler design difficult because the use of near and far pointers affects performance     addressing modes for    bit x   processors can be summarized by this formula     addressing modes for    bit address size on    bit or    bit x   processors can be summarized by this formula       addressing modes for    bit code on    bit x   processors can be summarized by this formula     instruction relative addressing in    bit code  rip   displacement  where rip is the instruction pointer register  simplifies the implementation of position independent code  as used in shared libraries in some operating systems      the      had   xa kb of   bit  or alternatively   xa k word of    bit  i o space  and a   xa kb  one segment  stack in memory supported by computer hardware  only words   xa bytes  can be pushed to the stack  the stack grows downwards  toward numerically lower addresses   its bottom being pointed by ss sp  there are     interrupts  which can be invoked by both hardware and software  the interrupts can cascade  using the stack to store the return address     for a description of the general notion of a cpu register  see processor register     the original intel      and      have fourteen    bit registers  four of them  ax  bx  cx  dx  are general purpose registers  gprs   although each may have an additional purpose  for example  only cx can be used as a counter with the loop instruction  each can be accessed as two separate bytes  thus bx s high byte can be accessed as bh and low byte as bl   two pointer registers have special roles  sp  stack pointer  points to the  top  of the stack  and bp  base pointer  is often used to point at some other place in the stack  typically above the local variables  see frame pointer   the registers si  di  bx and bp are address registers  and may also be used for array indexing     four segment registers  cs  ds  ss and es  are used to form a memory address  the flags register contains flags such as carry flag  overflow flag and zero flag  finally  the instruction pointer  ip  points to the next instruction that will be fetched from memory and then executed  this register cannot be directly accessed  read or written  by a program       the intel       and       are essentially an upgraded      or      cpu  respectively  with on chip peripherals added  and they have the same cpu registers as the      and       in addition to interface registers for the peripherals      the                    and       can use an optional floating point coprocessor  the       the      appears to the programmer as part of the cpu and adds eight    bit wide registers  st    to st     each of which can hold numeric data in one of seven formats            or    bit floating point            or    bit  binary  integer  and    bit packed decimal integer       in the intel        to support protected mode  three special registers hold descriptor table addresses  gdtr  ldtr  idtr   and a fourth task register  tr  is used for task switching  the       is the floating point coprocessor for the       and has the same registers as the      with the same data formats     with the advent of the    bit       processor  the    bit general purpose registers  base registers  index registers  instruction pointer  and flags register  but not the segment registers  were expanded to   xa bits  this is represented by prefixing an  e   for  extended   to the register names in x   assembly language  thus  the ax register corresponds to the lowest   xa bits of the new    bit eax register  si corresponds to the lowest   xa bits of esi  and so on  the general purpose registers  base registers  and index registers can all be used as the base in addressing modes  and all of those registers except for the stack pointer can be used as the index in addressing modes     two new segment registers  fs and gs  were added  with a greater number of registers  instructions and operands  the machine code format was expanded  to provide backward compatibility  segments with executable code can be marked as containing either    bit or    bit instructions  special prefixes allow inclusion of    bit instructions in a    bit segment or vice versa     the       had an optional floating point coprocessor  the        it had eight    bit wide registers  st    to st       like the      and         the       could also use an       coprocessor   with the       and all subsequent x   models  the floating point processing unit  fpu  was integrated on chip     with the pentium mmx  eight    bit mmx integer registers were added  mmx  to mmx   which share lower bits with the    bit wide fpu stack     with the pentium iii  a    bit streaming simd extensions  sse  control status register  mxcsr  and eight     bit sse floating point registers  xmm  to xmm   were added       starting with the amd opteron processor  the x   architecture extended the    bit registers into    bit registers in a way similar to how the    to    bit extension took place  an r prefix identifies the    bit registers  rax  rbx  rcx  rdx  rsi  rdi  rbp  rsp  rflags  rip   and eight additional    bit general registers  r  r    were also introduced in the creation of x       however  these extensions are only usable in    bit mode  which is one of the two modes only available in long mode  the addressing modes were not dramatically changed from    bit mode  except that addressing was extended to   xa bits  virtual addresses are now sign extended to   xa bits  in order to disallow mode bits in virtual addresses   and other selector details were dramatically reduced  in addition  an addressing mode was added to allow memory references relative to rip  the instruction pointer   to ease the implementation of position independent code  used in shared libraries in some operating systems     simd registers xmm  xmm       simd registers ymm  ymm       simd registers zmm  zmm       x   processors that have a protected mode  i e  the       and later processors  also have three descriptor registers  gdtr  ldtr  idtr  and a task register  tr         bit x   processors  starting with the        also include various special miscellaneous registers such as control registers  cr  through    cr  for    bit only   debug registers  dr  through    plus   and     test registers  tr  through          only   and model specific registers  msrs  appearing with the pentiumn      although the main registers  with the exception of the instruction pointer  are  general purpose  in the    bit and    bit versions of the instruction set and can be used for anything  it was originally envisioned that they be used for the following purposes     segment registers     no particular purposes were envisioned for the other   registers available only in    bit mode     some instructions compile and execute more efficiently when using these registers for their designed purpose  for example  using al as an accumulator and adding an immediate byte value to it produces the efficient add to al opcode of   h  whilst using the bl register produces the generic and longer add to register opcode of   c h  another example is double precision division and multiplication that works specifically with the ax and dx registers     modern compilers benefited from the introduction of the sib byte  scale index base byte  that allows registers to be treated uniformly  minicomputer like   however  using the sib byte universally is inoptimal  as it produces longer encodings than only using it selectively when necessary   the main benefit of the sib byte is the orthogonality and more powerful addressing modes it provides  which make it possible to save instructions and the use of registers for address calculations such as scaling an index   some special instructions lost priority in the hardware design and became slower than equivalent small code sequences  a notable example is the lodsw instruction     note  thexa  pl registers are only available in    bit mode     note  thexa  il registers are only available in    bit mode     real address mode    commonly called real mode  is an operating mode of      and later x   compatible cpus  real mode is characterized by a    bit segmented memory address space  meaning that only   mib of memory can be addressed actually  slightly moreo   direct software access to peripheral hardware  and no concept of memory protection or multitasking at the hardware level  all x   cpus in the       series and later start up in real mode at power on        cpus and earlier had only one operational mode  which is equivalent to real mode in later chips   on the ibm pc platform  direct software access to the ibm bios routines is available only in real mode  since bios is written for real mode  however  this is not a characteristic of the x   cpu but of the ibm bios design      in order to use more than   xa kb of memory  the segment registers must be used  this created great complications for compiler implementors who introduced odd pointer modes such as  near    far  and  huge  to leverage the implicit nature of segmented architecture to different degrees  with some pointers containing    bit offsets within implied segments and other pointers containing segment addresses and offsets within segments  it is technically possible to use up to    xa kb of memory for code and data  with up to   xa kb for code  by setting all four segment registers once and then only using    bit offsets  optionally with default segment override prefixes  to address memory  but this puts substantial restrictions on the way data can be addressed and memory operands can be combined  and it violates the architectural intent of the intel designers  which is for separate data items  e g  arrays  structures  code units  to be contained in separate segments and addressed by their own segment addresses  in new programs that are not ported from earlier   bit processors with    bit address spaces     in addition to real mode  the intel       supports protected mode  expanding addressable physical memory to    mb and addressable virtual memory to  xa gb  and providing protected memory  which prevents programs from corrupting one another  this is done by using the segment registers only for storing an index into a descriptor table that is stored in memory  there are two such tables  the global descriptor table  gdt  and the local descriptor table  ldt   each holding up to      segment descriptors  each segment giving access to   xa kb of memory  in the        a segment descriptor provides a    bit base address  and this base address is added to a    bit offset to create an absolute address  the base address from the table fulfills the same role that the literal value of the segment register fulfills in real mode  the segment registers have been converted from direct registers to indirect registers  each segment can be assigned one of four ring levels used for hardware based computer security  each segment descriptor also contains a segment limit field which specifies the maximum offset that may be used with the segment  because offsets are    bits  segments are still limited to   xa kb each in       protected mode       each time a segment register is loaded in protected mode  the       must read a   byte segment descriptor from memory into an a set of hidden internal registers  therefore  loading segment registers is much slower in protected mode than in real mode  and changing segments very frequently is to be avoided  actual memory operations using protected mode segments are not slowed much because the       and later have hardware to check the offset against the segment limit in parallel with instruction execution     the intel       extended offsets and also the segment limit field in each segment descriptor to    bits  enabling a segment to span the entire memory space  it also introduced support in protected mode for paging  a mechanism making it possible to use paged virtual memory  with  xa kb page size   paging allows the cpu to map any page of the virtual memory space to any page of the physical memory space  to do this  it uses additional mapping tables in memory called page tables  protected mode on the       can operate with paging either enabled or disabled  the segmentation mechanism is always active and generates virtual addresses that are then mapped by the paging mechanism if it is enabled  the segmentation mechanism can also be effectively disabled by setting all segments to have a base address of   and size limit equal to the whole address space  this also requires a minimally sized segment descriptor table of only four descriptors  since the fs and gs segments need not be used  p    paging is used extensively by modern multitasking operating systems  linux     bsd and windows nt were developed for the     because it was the first intel architecture cpu to support paging and    bit segment offsets  the     architecture became the basis of all further development in the x   series     x   processors that support protected mode boot into real mode for backward compatibility with the older      class of processors  upon power on  a k a  booting   the processor initializes in real mode  and then begins executing instructions  operating system boot code  which might be stored in rom  may place the processor into the protected mode to enable paging and other features  the instruction set in protected mode is backward compatible with the one used in real mode     there is also a sub mode of operation in    bit protected mode  a k a        protected mode  called virtual      mode  also known as v   mode  this is basically a special hybrid operating mode that allows real mode programs and operating systems to run while under the control of a protected mode supervisor operating system  this allows for a great deal of flexibility in running both protected mode programs and real mode programs simultaneously  this mode is exclusively available for the    bit version of protected mode  it does not exist in the    bit version of protected mode  or in long mode     in the mid     s  it was obvious that the    bit address space of the x   architecture was limiting its performance in applications requiring large data sets  a    bit address space would allow the processor to directly address only  xa gb of data  a size surpassed by applications such as video processing and database engines  using    bit addresses  it is possible to directly address   xa eib of data  although most    bit architectures do not support access to the full    bit address space  for example  amd   supports only   xa bits from a    bit address  split into four paging levels     in       amd published a  nearly  complete specification for a    bit extension of the x   architecture which they called x      with claimed intentions to produce  that design is currently used in almost all x   processors  with some exceptions intended for embedded systems     mass produced x      chips for the general market were available four years later  in       after the time was spent for working prototypes to be tested and refined  about the same time  the initial name x      was changed to amd    the success of the amd   line of processors coupled with lukewarm reception of the ia    architecture forced intel to release its own implementation of the amd   instruction set  intel had previously implemented support for amd     but opted not to enable it in hopes that amd would not bring amd   to market before itanium s new ia    instruction set was widely adopted  it branded its implementation of amd   as em  t  and later re branded it intel        in its literature and product version names  microsoft and sun refer to amd   intel    collectively as x   in the windows and solaris operating systems respectively  linux distributions refer to it either as  x        its variant  x  _     or  amd     bsd systems use  amd    while mac os x uses  x  _        long mode is mostly an extension of the    bit instruction set  but unlike the    to    bit transition  many instructions were dropped in the    bit mode  this does not affect actual binary backward compatibility  which would execute legacy code in other modes that retain support for those instructions   but it changes the way assembler and compilers for new code have to work     this was the first time that a major extension of the x   architecture was initiated and originated by a manufacturer other than intel  it was also the first time that intel accepted technology of this nature from an outside source     early x   processors could be extended with floating point hardware in the form of a series of floating point numerical co processors with names like             and        abbreviated x    this was also known as the npx  numeric processor extension   an apt name since the coprocessors  while used mainly for floating point calculations  also performed integer operations on both binary and decimal formats  with very few exceptions  the       and subsequent x   processors then integrated this x   functionality on chip which made the x   instructions a de facto integral part of the x   instruction set     each x   register  known as st    through st     is   xa bits wide and stores numbers in the ieee floating point standard double extended precision format  these registers are organized as a stack with st    as the top  this was done in order to conserve opcode space  and the registers are therefore randomly accessible only for either operand in a register to register instruction  st  must always be one of the two operands  either the source or the destination  regardless of whether the other operand is st x  or a memory operand  however  random access to the stack registers can be obtained through an instruction which exchanges any specified st x  with st        the operations include arithmetic and transcendental functions  including trigonometric and exponential functions  as well as instructions that load common constants  such as       e  the base of the natural logarithm  log       and log       into one of the stack registers  while the integer capability is often overlooked  the x   can operate on larger integers with a single instruction than the                     or any x   cpu without to    bit extensions can  and repeated integer calculations even on small values  e g     bit  can be accelerated by executing integer instructions on the x   cpu and the x   in parallel   the x   cpu keeps running while the x   coprocessor calculates  and the x   sets a signal to the x   when it is finished or interrupts the x   if it needs attention because of an error      mmx is a simd instruction set designed by intel and introduced in      for the pentium mmx microprocessor  the mmx instruction set was developed from a similar concept first used on the intel i     it is supported on most subsequent ia    processors by intel and other vendors  mmx is typically used for video processing  in multimedia applications  for instance      mmx added   new  registers  to the architecture  known as mm  through mm   henceforth referred to as mmn   in reality  these new  registers  were just aliases for the existing x   fpu stack registers  hence  anything that was done to the floating point stack would also affect the mmx registers  unlike the fp stack  these mmn registers were fixed  not relative  and therefore they were randomly accessible  the instruction set did not adopt the stack like semantics so that existing operating systems could still correctly save and restore the register state when multitasking without modifications     each of the mmn registers are    bit integers  however  one of the main concepts of the mmx instruction set is the concept of packed data types  which means instead of using the whole register for a single    bit integer  quadword   one may use it to contain two    bit integers  doubleword   four    bit integers  word  or eight   bit integers  byte   given that the mmx s    bit mmn registers are aliased to the fpu stack and each of the floating point registers are   xa bits wide  the upper   xa bits of the floating point registers are unused in mmx  these bits are set to all ones by any mmx instruction  which correspond to the floating point representation of nans or infinities     in      amd introduced  dnow   the introduction of this technology coincided with the rise of  d entertainment applications and was designed to improve the cpu s vector processing performance of graphic intensive applications   d video game developers and  d graphics hardware vendors use  dnow  to enhance their performance on amd s k  and athlon series of processors      dnow  was designed to be the natural evolution of mmx from integers to floating point  as such  it uses exactly the same register naming convention as mmx  that is mm  through mm   the only difference is that instead of packing integers into these registers  two single precision floating point numbers are packed into each register  the advantage of aliasing the fpu registers is that the same instruction and data structures used to save the state of the fpu registers can also be used to save  dnow  register states  thus no special modifications are required to be made to operating systems which would otherwise not know about them     in       intel introduced the streaming simd extensions  sse  instruction set  following in      with sse   the first addition allowed offloading of basic floating point operations from the x   stack and the second made mmx almost obsolete and allowed the instructions to be realistically targeted by conventional compilers  introduced in      along with the prescott revision of the pentium   processor  sse  added specific memory and thread handling instructions to boost the performance of intel s hyperthreading technology  amd licensed the sse  instruction set and implemented most of the sse  instructions for its revision e and later athlon    processors  the athlon    does not support hyperthreading and lacks those sse  instructions used only for hyperthreading     sse discarded all legacy connections to the fpu stack  this also meant that this instruction set discarded all legacy connections to previous generations of simd instruction sets like mmx  but it freed the designers up  allowing them to use larger registers  not limited by the size of the fpu registers  the designers created eight     bit registers  named xmm  through xmm    note  in amd    the number of sse xmm registers has been increased from   to      however  the downside was that operating systems had to have an awareness of this new set of instructions in order to be able to save their register states  so intel created a slightly modified version of protected mode  called enhanced mode which enables the usage of sse instructions  whereas they stay disabled in regular protected mode  an os that is aware of sse will activate enhanced mode  whereas an unaware os will only enter into traditional protected mode     sse is a simd instruction set that works only on floating point values  like  dnow   however  unlike  dnow  it severs all legacy connection to the fpu stack  because it has larger registers than  dnow   sse can pack twice the number of single precision floats into its registers  the original sse was limited to only single precision numbers  like  dnow   the sse  introduced the capability to pack double precision numbers too  which  dnow  had no possibility of doing since a double precision number is    bit in size which would be the full size of a single  dnow  mmn register  at    xa bits  the sse xmmn registers could pack two double precision floats into one register  thus sse  is much more suitable for scientific calculations than either sse  or  dnow   which were limited to only single precision  sse  does not introduce any additional registers     physical address extension or pae was first added in the intel pentium pro  to allow an additional  xa bits of physical addressing in    bit protected mode  the size of memory in protected mode is usually limited to  xa gb  through tricks in the processor s page and segment memory management systems  x   operating systems may be able to access more than    bits of address space  even without the switchover to the    bit paradigm  this mode does not change the length of segment offsets or linear addresses  those are still only   xa bits     by the     s it had become obvious that    bit x   processors  limitations in memory addressing were an obstacle to their utilization in high performance computing clusters and powerful desktop workstations  the aged    bit x   was competing with much more advanced    bit risc architectures which could address much more memory  intel and the whole x   ecosystem needed    bit memory addressing if x   was to survive the    bit computing era  as workstation and desktop software applications were soon to start hitting the limitations present in    bit memory addressing  however  intel felt that it was the right time to make a bold step and use the transition to    bit desktop computers for a transition away from the x   architecture in general  an experiment which ultimately failed     in       intel attempted to introduce a non x      bit architecture named ia    in its itanium processor  initially aiming for the high performance computing market  hoping that it would eventually replace the    bit x      while ia    was incompatible with x    the itanium processor did provide emulation capabilities for translating x   instructions into ia     but this affected the performance of x   programs so badly that it was rarely  if ever  actually useful to the users  programmers should rewrite x   programs for the ia    architecture or their performance on itanium would be orders of magnitude worse than on a true x   processor  the market rejected the itanium processor since it broke backward compatibility and preferred to continue using x   chips  and very few programs were rewritten for ia        amd decided to take another path toward    bit memory addressing  making sure backward compatibility would not suffer  in april       amd released the first x   processor with    bit physical memory address registers  capable of addressing much more than  xa gb of memory using the new x      extension  also known as amd   or x    which introduced the long mode  the    bit extensions to the x   architecture were enabled only in long mode  therefore    bit and    bit applications could simply continue using an amd   processor in protected or other modes  without even the slightest sacrifice of performance   and with full compatibility back to the original instructions of the    bit intel         p       the market responded positively  adopting the    bit amd processors for both high performance applications and business or home computers     seeing the market rejecting the incompatible itanium processor and microsoft supporting amd    intel had to respond and introduced its own x      processor in july         as a result  the itanium processor with its ia    instruction set is rarely used today and x    through its x      incarnation  is still the dominant cpu architecture in non embedded computers     x      also introduced the nx bit  which offers some protection against security bugs caused by buffer overruns     as a result of amd s    bit contribution to the x   lineage and its subsequent acceptance by intel  the    bit risc architectures ceased to be a threat to the x   ecosystem and almost disappeared from the workstation market  x      began to be utilized in powerful supercomputers  in its amd opteron and intel xeon incarnations   a market which was previously the natural habitat for    bit risc designs  such as the ibm power microprocessors or sparc processors   the great leap toward    bit computing and the maintenance of backward compatibility with    bit and    bit software enabled the x   architecture to become an extremely flexible platform today  with x   chips being utilized from small low power systems  for example  intel quark and intel atom  to fast gaming desktop computers  for example  intel core i  and amd fx   and even dominate large supercomputing clusters  effectively leaving only the arm    bit and    bit risc architecture as a competitor in the smartphone and tablet market     prior to      x   architecture processors were unable to meet the popek and goldberg requirements   a specification for virtualization created in      by gerald j  popek and robert p  goldberg  however both commercial and open source x   virtualization hypervisor products were developed using software based virtualization  commercial systems included vmware esx  vmware workstation  parallels  microsoft hyper v server  and microsoft virtual pc  while open source systems included qemu kqemu  virtualbox  and xen     the introduction of the amd v and intel vt x instruction sets in      allowed x   processors to meet the popek and goldberg virtualization requirements    