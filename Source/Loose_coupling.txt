 in computing and systems design a loosely coupled system is one in which each of its components has  or makes use of  little or no knowledge of the definitions of other separate components  sub areas include the coupling of classes  interfaces  data  and services             coupling refers to the degree of direct knowledge that one component has of another  this is not meant to be interpreted as encapsulation vs  non encapsulation     an example of tight coupling occurs when a dependent class contains a pointer directly to a concrete class which provides the required behavior  the dependency cannot be substituted  or its  signature  changed  without requiring a change to the dependent class  loose coupling occurs when the dependent class contains a pointer only to an interface  which can then be implemented by one or many concrete classes  the dependent class s dependency is to a  contract  specified by the interface  a defined list of methods and or properties that implementing classes must provide  any class that implements the interface can thus satisfy the dependency of a dependent class without having to change the class  this allows for extensibility in software design  a new class implementing an interface can be written to replace a current dependency in some or all situations  without requiring a change to the dependent class  the new and old classes can be interchanged freely  strong coupling does not allow this     this is a uml diagram  created in ibm rhapsody  illustrating an example of loose coupling between a dependent class and a set of concrete classes  which provide the required behavior         for comparison  this diagram illustrates the alternative design with strong coupling between the dependent class and a provider         computer programming languages having notions of either functions as the core module  see functional programming  or functions as objects provide excellent examples of loosely coupled programming  functional languages have patterns of continuations  closure  computer programming   or generators  see clojure and lisp as examples of function programming languages  object oriented languages like smalltalk and ruby have code blocks  while eiffel has agents  the basic idea is to objectify  encapsulate as an object  a function independent of any other enclosing concept  e g  decoupling an object function from any direct knowledge of the enclosing object   see first class function for further insight into functions as objects  which qualifies as one form of first class function     so  for example  in an object oriented language  when a function of an object is referenced as an object  freeing it from having any knowledge of its enclosing host object  the new function object can be passed  stored  and called at a later time  recipient objects  to whom these functional objects are given  can safely execute  call  the contained function at their own convenience without any direct knowledge of the enclosing host object  in this way  a program can execute chains or groups of functional objects  while safely decoupled from having any direct reference to the enclosing host object     phone numbers are an excellent analog and can easily illustrate the degree of this decoupling     for example  some entity provides another with a phone number to call to get a particular job done  when the number is called  the calling entity is effectively saying   please do this job for me   the decoupling or loose coupling is immediately apparent  the entity receiving the number to call may have no knowledge of where the number came from  e g  a reference to the supplier of the number   on the other side  the caller is decoupled from specific knowledge of who they are calling  where they are  and knowing how the receiver of the call operates internally     carrying the example a step further  the caller might say to the receiver of the call   please do this job for me  call me back at this number when you are finished   the `number  being offered to the receiver is referred to as a  call back   again  the loose coupling or decoupled nature of this functional object is apparent  the receiver of the call back is unaware of what or who is being called  it only knows that it can make the call and decides for itself when to call  in reality  the call back may not even be to the one who provided the call back in the first place  this level of indirection is what makes function objects an excellent technology for achieving loosely coupled programs     the degree of the loose coupling can be measured by noting the number of changes in data elements that could occur in the sending or receiving systems and determining if the computers would still continue communicating correctly  these changes include items such as     loose coupling of interfaces can be enhanced when publishers of data transmit messages using a standardised file format  such as xml or json      coupling between program components can be enhanced by using standard data types in parameters  passing customised data types or objects requires both components to have knowledge of the custom data definition     loose coupling of services can be enhanced by reducing the information passed into a service to the key data  for example  a service that sends a letter is most reusable when just the customer identifier is passed and the customer address is obtained within the service  this decouples services because services do not need to be called in a specific order  e g  getcustomeraddress  sendletter     note that loose coupling is not universally positive  if systems are de coupled in time using message oriented middleware  it is difficult to also provide transactional integrity  data replication across different systems provides loose coupling  in availability   but creates issues in maintaining synchronisation  